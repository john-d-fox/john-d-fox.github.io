

## -------------------------------------------------------------------------------------------------------------------------------
curve(sin, 0, 2*pi, ann=FALSE, axes=FALSE, lwd=2)
axis(1, pos=0, at=c(0, pi/2, pi, 3*pi/2, 2*pi),
    labels=c(expression(0*degree), expression(90*degree), 
             expression(180*degree), expression(270*degree), 
             expression(360*degree)))
axis(2, pos=0)
curve(cos, add=TRUE, lty="dashed", lwd=2)
legend(pi, 1, lty=1:2, lwd=2, legend=c("sine", "cosine"), bty="n")


## -------------------------------------------------------------------------------------------------------------------------------
(angles <- seq(0, pi, length=6))
(c <- cos(angles))
(s <- sin(angles + pi/2))
all(c == s)
c - s


## -------------------------------------------------------------------------------------------------------------------------------
(A <- matrix(1:6, nrow=2, ncol=3, byrow=TRUE))
(B <- matrix(c(-5, 1, 2, 3, 0, -4), nrow=2, ncol=3, byrow=TRUE))
(C <- A + B) # addition
(D <- A - B) # subtraction
(E <- -B) # negation
t(A) # transpose


## -------------------------------------------------------------------------------------------------------------------------------
(F <- 3*B)


## -------------------------------------------------------------------------------------------------------------------------------
c(2, 0, 1, 3) %*% c(-1, 6, 0, 9)


## -------------------------------------------------------------------------------------------------------------------------------
A # recall
(I_3 <- diag(3)) # order-3 identity matrix
A %*% I_3
(W <- matrix(1:4, 2, 2, byrow=TRUE))
(X <- matrix(c(0, 3, 2, 1), 2, 2, byrow=TRUE))
W %*% X  # W and X don't commute
X %*% W
(Y <- diag(c(2, 3)))
(Z <- diag(c(1/2, 1/3)))
Y %*% Z  # Y and Z commute
Z %*% Y


## -------------------------------------------------------------------------------------------------------------------------------
(A <- matrix(c(2, 5, 1, 3), 2, 2, byrow=TRUE))
(B <- matrix(c(3, -5, -1, 2), 2, 2, byrow=TRUE)) # B = A^-1
A %*% B # check = I
B %*% A


## -------------------------------------------------------------------------------------------------------------------------------
library("matlib")
(A <- matrix(c(2, -2,  0,
               1, -1,  1,
               4,  4, -4),
             3, 3, byrow=TRUE))
B <- gaussianElimination(A, diag(3), verbose=TRUE, fractions=TRUE)
(B <- B[, 4:6]) # B should be A^-1
A %*% B # check = I
B %*% A


## -------------------------------------------------------------------------------------------------------------------------------
solve(A) # = A^-1
det(A)


## -------------------------------------------------------------------------------------------------------------------------------
X <- matrix(c(-1, 1,
               1, 2,
               3,-1,
              -2,-2), 
            4, 2, byrow=TRUE)
rownames(X) <- c("(-1, 1)'", "(1, 2)'", "(3, -1)'", "(-2, -2)'")
plot(c(-2, 3.5), c(-2.5, 2.5), type="n", 
     xlab=expression(x[1]), ylab=expression(x[2]), asp=1)
abline(v=0, h=0, col="gray")
vectors(X, cex=0.8)


## -------------------------------------------------------------------------------------------------------------------------------
X <- matrix(c(1,-2,
              2, 3,
              3, 1), 
            3, 2, byrow=TRUE)
rownames(X) <- c("(1, -2)'", "(2, 3)'", "(3, 1)'")
plot(c(0, 3), c(-2, 3), type="n", 
     xlab=expression(x[1]), ylab=expression(x[2]), asp=1)
abline(v=0, h=0, col="gray")
vectors(X, cex=0.8)
segments(x0=c(2, 1), x1=c(3, 3), y0=c(3, -2), y1=c(1, 1))


## -------------------------------------------------------------------------------------------------------------------------------
X <- matrix(c(3,   2,
              4.5, 3,
             -3,  -2), 
            3, 2, byrow=TRUE)
rownames(X) <- c("x = (3, 2)'", "1.5x = (4.5, 3)'", "-x = (-3, -1)'")
plot(c(-3, 7), c(-2, 4.5), type="n", 
     xlab=expression(x[1]), ylab=expression(x[2]), asp=1)
abline(v=0, h=0, col="gray")
vectors(X, cex=0.8)


## -------------------------------------------------------------------------------------------------------------------------------
A <- matrix(c(-2, 0,-1, 2,
               4, 0, 1, 0,
               6, 0, 1, 2),
            3, 4, byrow=TRUE)
gaussianElimination(A, verbose=TRUE, fractions=TRUE)


## -------------------------------------------------------------------------------------------------------------------------------
gaussianElimination(A, c(1, 2, 5), verbose=TRUE, fractions=TRUE)


## -------------------------------------------------------------------------------------------------------------------------------
gaussianElimination(A, c(1, 2, 1), verbose=TRUE, fractions=TRUE)


## -------------------------------------------------------------------------------------------------------------------------------
A # recall
B <- Ginv(A, verbose=TRUE, fractions=TRUE)
B # A^-
A %*% B %*% A # check


## -------------------------------------------------------------------------------------------------------------------------------
library("MASS")
fractions(M <- ginv(A)) # A^+
zapsmall(A %*% M %*% A) # check = A
fractions(M %*% A %*% M) # check = M
fractions(A %*% M) # check symmetry
fractions(M %*% A) # check symmetry


## -------------------------------------------------------------------------------------------------------------------------------
(A <- matrix(c(1, 0.5, 0.5, 1), 2, 2))
(X.eig <- eigen(A))
(X.Eig <- Eigen(A))
X.eig$vectors %*% diag(X.eig$values) %*% t(X.eig$vectors) # check = A
X.Eig$vectors %*% diag(X.Eig$values) %*% t(X.Eig$vectors) # ditto


## -------------------------------------------------------------------------------------------------------------------------------
(A <- matrix(c(1, 0.5, 0.3, 0.5, 1, 0.5, 0.3, 0.5, 1), 3, 3))
(L <- cholesky(A))
(U <- chol(A))
L %*% t(L) # check = A
t(U) %*% U # ditto


## -------------------------------------------------------------------------------------------------------------------------------
(X <- matrix(c(1, 1, 2,
              1, 1, 4,
              1, 0, 6,
              1, 0, 8),
            4, 3, byrow=TRUE))
(QR.X <- QR(X))
QR.X$Q %*% QR.X$R # check =X
qr.X <- qr(X)
names(qr.X)
qr.X$rank
qr.Q(qr.X)
qr.R(qr.X)


## -------------------------------------------------------------------------------------------------------------------------------
library("mosaicCalc")
(dy_dx <- D(x^2 ~ x))


## -------------------------------------------------------------------------------------------------------------------------------
dy_dx(1:3)


## -------------------------------------------------------------------------------------------------------------------------------
D(3*x^6 ~ x)  # note: not simplified!


## -------------------------------------------------------------------------------------------------------------------------------
D((1/4)*x^-3 ~ x) # again not simplified


## -------------------------------------------------------------------------------------------------------------------------------
D(x^(1/2) ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
D(2*x^2 + 3*x + 4 ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
D((x^2 + 1)*(2*x^3 - 3*x) ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
# following is equivalent to f'(x) = (-(x^2) + 5)/((x^2 - 3*x + 5)^2):
D(x/(x^2 - 3*x +5) ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
D((x^2 + 3*x + 6)^5 ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
D(log(x) ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
D(exp(x) ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
D(a^x ~ x) # note: returns a function of x and a


## -------------------------------------------------------------------------------------------------------------------------------
D(cos(x) ~ x)
D(sin(x) ~ x)
D(tan(x) ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
D(5*x^4 + 3*x^2 + 6 ~ x) # f'(x)
D(5*x^4 + 3*x^2 + 6 ~ x + x) # f''(x)
D(5*x^4 + 3*x^2 + 6 ~ x + x + x) # f'''(x)
D(5*x^4 + 3*x^2 + 6 ~ x + x + x + x) # f''''(x)
D(5*x^4 + 3*x^2 + 6 ~ x + x + x + x + x) # f'''''(x)


## -------------------------------------------------------------------------------------------------------------------------------
D(2*x^3 - 9*x^2 + 12*x +6 ~ x)


## -------------------------------------------------------------------------------------------------------------------------------
polyroot(c(12, -18, 6))


## -------------------------------------------------------------------------------------------------------------------------------
f <- function(x) 2*x^3 - 9*x^2 + 12*x +6
f(c(1, 2))


## -------------------------------------------------------------------------------------------------------------------------------
(fpp <- D(2*x^3 - 9*x^2 + 12*x +6 ~ x + x))
fpp(c(1, 2))


## -------------------------------------------------------------------------------------------------------------------------------
curve(2*x^3 - 9*x^2 + 12*x +6, from=0, to=3, lwd=2, ylim=c(0, 15),
      ylab = expression(f(x) == 2*x^3 - 9*x^2 + 12*x +6))
abline(h=c(10, 11), v=c(1, 2), lty=2)


## -------------------------------------------------------------------------------------------------------------------------------
D(x_1^2 + 3*x_1*x_2^2 + x_2^3 ~ x_1)
D(x_1^2 + 3*x_1*x_2^2 + x_2^3 ~ x_2)


## -------------------------------------------------------------------------------------------------------------------------------
(fp1 <- D(x_1^2 + x_1*x_2 + x_2^2 + 10 ~ x_1))
(fp2 <- D(x_1^2 + x_1*x_2 + x_2^2 + 10 ~ x_2))


## -------------------------------------------------------------------------------------------------------------------------------
(A <- matrix(c(2, 1, 1, 2), 2, 2))
solve(A, c(0, 0))



## -------------------------------------------------------------------------------------------------------------------------------
f <- function(x_1, x_2) x_1^2 + x_1*x_2 + x_2^2 + 10
f(0, 0)


## -------------------------------------------------------------------------------------------------------------------------------
fp1(1, 2)
fp2(2, 1)


## -------------------------------------------------------------------------------------------------------------------------------
D(x_1^2 + x_2^2 - lambda*(x_1 + x_2 - 1) ~ x_1)
D(x_1^2 + x_2^2 - lambda*(x_1 + x_2 - 1) ~ x_2)
D(x_1^2 + x_2^2 - lambda*(x_1 + x_2 - 1) ~ lambda)


## -------------------------------------------------------------------------------------------------------------------------------
(A <- matrix(c(2, 0, -1,
               0, 2, -1,
              -1,-1,  0),
             3, 3, byrow=TRUE))
solve(A, c(0, 0, -1))


## -------------------------------------------------------------------------------------------------------------------------------
D(x_1^2 + x_1*x_2 + x_2^2 + 10 ~ x_1 + x_2)
D(x_1^2 + x_1*x_2 + x_2^2 + 10 ~ x_2 + x_1)
D(x_1^2 + x_1*x_2 + x_2^2 + 10 ~ x_1 + x_1)
D(x_1^2 + x_1*x_2 + x_2^2 + 10 ~ x_2 + x_2)


## -------------------------------------------------------------------------------------------------------------------------------
minimize <- function(f, df, x0, tol=1e-5, adjust.step=TRUE, verbose=FALSE){
    # f:           function to be minimized
    # df:          function for the vector partial derivative (gradient) of f
    # x0:          vector of starting values for x
    # tol:         a small positive number to test for convergence,
    #              to be treated as effectively zero
    # adjust.step: if TRUE, adjust the step size if there is no improvement
    # verbose:     if TRUE, print iteration history
    it <- 0L
    step <- 1
    x <- x0
    if (verbose){
        cat("\nit =", it,"  step =", step, "  x =", x0, 
            "  f(x) =", f(x0), "  f'(x) =", df(x0))
    }
    while (abs(df(x)) > tol){
        it <- it + 1L
        x1 <- x - step*fp(x)
        if (f(x1) < f(x)){
            x <- x1
            if (verbose){
                cat("\nit =", it,"  step =", step, "  x =", x, 
                    "  f(x) =", f(x), "  f'(x) =", df(x))
            }
            if (adjust.step) {
                step <- step*2
                if (verbose){
                    cat("\n  adjusted (*2) step =", step)
                }
            }
        } else {
            step <- step/2
            if (verbose){
                cat("\n  adjusted (/2) step =", step)
            }
            it <- it - 1L
        }
    }
    # return a list with x at the minimum, the minimum, the gradient at the minimum,
    #  and the number of iterations required
    list(x=x, f=f(x), df=df(x), it=it)
}


## -------------------------------------------------------------------------------------------------------------------------------
(fp <- D(x^4 - 10*x^3 + 35*x^2 - 50*x + 26 ~ x))


## -------------------------------------------------------------------------------------------------------------------------------
f <- function(x) x^4 - 10*x^3 + 35*x^2 - 50*x + 26
minimize(f, fp, x0=3, verbose=TRUE)


## -------------------------------------------------------------------------------------------------------------------------------
optim(3, f, gr=fp, method="BFGS")


## -------------------------------------------------------------------------------------------------------------------------------
optimize(f, c(0, 4))


## -------------------------------------------------------------------------------------------------------------------------------
optimize(f, c(2, 4))



## -------------------------------------------------------------------------------------------------------------------------------
(F <- antiD(x^2 + 3 ~ x))


## -------------------------------------------------------------------------------------------------------------------------------
F(3) - F(1)


## -------------------------------------------------------------------------------------------------------------------------------
integrate(function(x){x^2 + 3}, lower=1, upper=3)


## -------------------------------------------------------------------------------------------------------------------------------
x <- 0:10
p <- dbinom(x, size=10, prob=0.7)
cbind(x, p) # table of probabilities
plot(x, p, ylab="p(x)", type="h")
points(x, p, pch=16)
abline(h=0, lty=2)


## -------------------------------------------------------------------------------------------------------------------------------
P <- pbinom(x, size=10, prob=0.7)
cbind(x, P) # table of cumulative probabilities
plot(x, P, ylab="P(x)", type="s")
points(x, P, pch=16)
abline(h=c(0, 1), lty=2)


## -------------------------------------------------------------------------------------------------------------------------------
qbinom(0.95, size=10, prob=0.7)


## -------------------------------------------------------------------------------------------------------------------------------
set.seed(327429734) # for reproducibility
X <- rbinom(1000, size=10, prob=0.7)
(counts <-table(X))
plot(2:10, as.vector(counts), type="h", xlab="x", xlim=c(0, 10))
points(2:10, counts, pch=16)
abline(h=0, lty=2)
mean(X)
sd(X)


## -------------------------------------------------------------------------------------------------------------------------------
x <- seq(0, 20, length=1000)
plot(x, dnorm(x, mean=10, sd=sqrt(9)), type="l", ylab="p(x)", lwd=2)
abline(h=0, lty=2)

## -------------------------------------------------------------------------------------------------------------------------------
plot(x, pnorm(x, mean=10, sd=sqrt(9)), type="l", ylab="P(x)", lwd=2)
abline(h=c(0, 1), lty=2)


## -------------------------------------------------------------------------------------------------------------------------------
qnorm(c(0.025, 0.975), mean=10, sd=3)


## -------------------------------------------------------------------------------------------------------------------------------
library("car") # for densityPlot()
set.seed(4747834)
X <- rnorm(1000, mean=10, sd=3)
densityPlot(X, method="kernel", col="cyan")
lines(x, dnorm(x, mean=10, sd=3), lwd=2, lty=2, col="magenta")
legend("topleft", inset=0.05, lty=1:2, lwd=2, col=c("cyan", "magenta"), 
       legend=c("sample", "population"))
mean(X)
sd(X)


## ----fig.width=7----------------------------------------------------------------------------------------------------------------
library("mvtnorm")
library("lattice") # for wireframe()

mu <- c(5, 6)
Sigma <- matrix(c(1.5^2, 2.25, 2.25, 3^2), 2, 2)
x <- seq(0, 12, length=25)
X <- expand.grid(x1=x, x2=x)
X$p <- dmvnorm(X, mean=mu, sigma=Sigma)
head(X)
tail(X)

wireframe(p ~ x1 + x2, data=X, scales=list(arrows=FALSE),
          xlab=expression(x[1]), ylab=expression(x[2]), 
          zlab=list(label=expression(p(x[1], x[2])), rot=90))


## -------------------------------------------------------------------------------------------------------------------------------
x <- seq(0, 12, length=100)
X <- expand.grid(x1=x, x2=x)
X$p <- dmvnorm(X, mean=mu, sigma=Sigma)
contourplot(p ~ x1 + x2, data=X, xlab=expression(x[1]), ylab=expression(x[2]), lwd=2,
            panel=function(x, y, ...){
              panel.contourplot(x, y, ...)
              panel.abline(h=6, v=5, lty=2)
              panel.points(x=5, y=6, pch=16, cex=1.5, col="black")
            })


## -------------------------------------------------------------------------------------------------------------------------------
ellipse(center=mu, shape=Sigma, radius=sqrt(qchisq(.95, 2)), add=FALSE,
        xlab=expression(x[1]), ylab=expression(x[2]),
        col="black", fill=TRUE, asp=1) # 95% concentration ellipse
ellipse(center=mu, shape=Sigma, radius=1, col="black", fill=TRUE) # standard ellipse
abline(v=c(3.5, 5, 6.5), h=c(3, 6, 9), lty=2)


## -------------------------------------------------------------------------------------------------------------------------------
par(mfrow=c(2, 2))

x<-seq(-2, 6, length=10000)

n <- 1
dg <- n*dgamma(x*n, shape=n)
dg[x < 0] <- NA
dn <- dnorm(x, 1, 1/sqrt(n))
plot(range(x), range(dn, dg, na.rm=TRUE), type="n",
    xlab=expression(bar(x)),
    ylab=expression(p(bar(x))), 
    main="(a) n = 1")
lines(x, dg, lwd=2)
lines(x, dn, lwd=2, lty=2)
abline(v=0, h=0)

n <- 2
dg <- n*dgamma(x*n, shape=n)
dg[x < .01] <- NA
dn <- dnorm(x, 1, 1/sqrt(n))
plot(range(x), range(dn, dg, na.rm=TRUE), type="n",
    xlab=expression(bar(x)),
    ylab=expression(p(bar(x))),
    main="(b) n = 2")
lines(x, dg, lwd=2)
lines(x, dn, lwd=2, lty=2)
abline(v=0, h=0)

n <- 5
dg <- n*dgamma(x*n, shape=n)
dg[x < .01] <- NA
dn <- dnorm(x, 1, 1/sqrt(n))
plot(range(x), range(dn, dg, na.rm=TRUE), type="n",
    xlab=expression(bar(x)),
    ylab=expression(p(bar(x))),
    main="(d) n = 5")
lines(x, dg, lwd=2)
lines(x, dn, lwd=2, lty=2)
abline(v=0, h=0)

n <- 25
dg <- n*dgamma(x*n, shape=n)
dg[x < .01] <- NA
dn <- dnorm(x, 1, 1/sqrt(n))
plot(range(x), range(dn, dg, na.rm=TRUE), type="n",
    xlab=expression(bar(x)),
    ylab=expression(p(bar(x))),
    main="(d) n = 25")
lines(x, dg, lwd=2)
lines(x, dn, lwd=2, lty=25)
abline(v=0, h=0)


## -------------------------------------------------------------------------------------------------------------------------------
x <- c(-0.068, -1.282, 0.013, 0.141, -0.980, 1.263, 10) 


## ----fig.height=3---------------------------------------------------------------------------------------------------------------
library("RcmdrMisc")
Dotplot(x)
mean(x)
median(x)


## -------------------------------------------------------------------------------------------------------------------------------
rlm(x ~ 1, k=1.345, psi=psi.huber)
rlm(x ~ 1, c=4.685, psi=psi.bisquare)


## -------------------------------------------------------------------------------------------------------------------------------
remove("x") # residue of the preceding example
D(x*log(phi) + (n - x)*log(1 - phi) ~ phi)


## -------------------------------------------------------------------------------------------------------------------------------
D(x*log(phi) + (n - x)*log(1 - phi) ~ phi + phi)


## -------------------------------------------------------------------------------------------------------------------------------
remove("X", "mu") # residue of a previous example
D(-(n/2)*log(sigma2) - (1/(2*sigma2))*(X - mu)^2 ~ mu)
D(-(n/2)*log(sigma2) - (1/(2*sigma2))*(X - mu)^2 ~ sigma2)


## -------------------------------------------------------------------------------------------------------------------------------
D(log(phi/(1 - phi)) ~ phi)


## -------------------------------------------------------------------------------------------------------------------------------
x <- seq(0, 1, length=1000)
d1 <- dbeta(x, 8, 4)
d2 <- dbeta(x, 23, 19)
plot(rep(x,2), c(d1, d2), type="n", 
     xlab=expression(phi), ylab=expression(p(phi)))
lines(x, d1, lty=1, lwd=2)
lines(x, d2, lty=2, lwd=2)
legend("topleft", lty=1:2, lwd=rep(2, 3), legend=c(
  "a = 1, b = 1",
  "a = 16, b = 16"), 
  title="Posterior for Beta(a, b) Prior", inset=0.02)
lines(c(qbeta(.025, 8, 4), qbeta(.975, 8, 4)), rep(0.2, 2), lwd=3)
lines(c(qbeta(.025, 23, 19), qbeta(.975, 23, 19)), rep(0.3, 2), lwd=3, lty=2)
abline(h=0)
lines(rep(x[which.max(d1)], 2), c(0, max(d1)), lty=2)
lines(rep(x[which.max(d2)], 2), c(0, max(d2)), lty=2)


## -------------------------------------------------------------------------------------------------------------------------------
p.star <- function(x, mu, Sigma){
    exp(- 0.5 * (x - mu) %*% solve(Sigma) %*% (x - mu))
}

mu <- c(1, 2)
(Sigma <- matrix(c(1, 1, 1, 4), 2, 2))

# check
some.xs <- list(c(1, 2), c(0, 0), c(3, 3))
sapply(some.xs, p.star, mu=mu, Sigma=Sigma) / 
    sapply(some.xs, dmvnorm, mean=mu, sigma=Sigma)
2*pi*sqrt(3)  # check normalizing constant


## -------------------------------------------------------------------------------------------------------------------------------
m <- 1e5  # draws
x.current <- c(0, 0)  # x_0
xs <- matrix(0, m, 2)  # to hold sampled values

set.seed(811018)  # for reproducibility

delta <- c(2, 4)  # for bivariate uniform proposal distribution

rbvunif <- function(mu, delta){
    u1 <- runif(1, mu[1] - delta[1], mu[1] + delta[1])
    u2 <- runif(1, mu[2] - delta[2], mu[2] + delta[2])
    c(u1, u2)
}

accepted <- rejected <- 0

system.time(
    for (i in 1:m){
        x.proposed <- rbvunif(mu=x.current, delta=delta)  # proposal
        a <- p.star(x.proposed, mu, Sigma) /
            p.star(x.current, mu, Sigma)  # acceptance ratio
        if (a >= 1 || runif(1) <= a) {
            xs[i, ] <- x.proposed
            x.current <- x.proposed
            accepted <- accepted + 1
        }
        else {
            xs[i, ] <- x.current
            rejected <- rejected + 1
        }
    }
)

accepted/m
accepted + rejected


## -------------------------------------------------------------------------------------------------------------------------------
colMeans(xs)
cov(xs)


## ----fig.height=4---------------------------------------------------------------------------------------------------------------
par(mfrow=c(1, 2))
acf(xs[, 1])
acf(xs[, 2])


## ----eval=FALSE-----------------------------------------------------------------------------------------------------------------
eqscplot(0, 0, type="n", xlim=c(-4, 8), ylim=c(-4, 8),
         xlab=expression(x[1]), ylab=expression(x[2]))
ellipse(mu, Sigma, col='blue', radius=sqrt(qchisq(.95, 2)), lty=2)

m <- 300
pb <- txtProgressBar(1, m, initial=1, style=3)
points(xs[1, 1], xs[1, 2])
for (i in 2:m){
    Sys.sleep(0.1)
    setTxtProgressBar(pb, i)
    lines(xs[c(i, i - 1), ], col="gray")
    points(xs[i, 1], xs[i, 2],
           col = if(all(xs[i, ] == xs[i - 1,])) "magenta" else "black")
}
close(pb)


## ----echo=FALSE-----------------------------------------------------------------------------------------------------------------
eqscplot(0, 0, type="n", xlim=c(-4, 8), ylim=c(-4, 8),
         xlab=expression(x[1]), ylab=expression(x[2]))
ellipse(mu, Sigma, col='blue', radius=sqrt(qchisq(.95, 2)), lty=2)

m <- 300
points(xs[1, 1], xs[1, 2])
for (i in 2:m){
    lines(xs[c(i, i - 1), ], col="gray")
    points(xs[i, 1], xs[i, 2],
           col = if(all(xs[i, ] == xs[i - 1,])) "magenta" else "black")
}


## -------------------------------------------------------------------------------------------------------------------------------
set.seed(54321) # for reprodibility
mu <- c(5, 6)
Sigma <- matrix(c(1.5^2, 2.25, 2.25, 3^2), 2, 2)
X <- rmvnorm(100, mu, Sigma)
Data <- data.frame(X)
X <- cbind(1, X)
names(X) <- c("constant", "X1", "X2")
eps <- rnorm(100, 0, 5)
Beta <- c(3, 1.5, 2)
y <- X %*% Beta + eps
Data$y <- y
summary(model <- lm(y ~ X1 + X2, data=Data))


## -------------------------------------------------------------------------------------------------------------------------------
(b <- solve(t(X) %*% X) %*% t(X) %*% y)


## -------------------------------------------------------------------------------------------------------------------------------
qr.x <- QR(X)
qr.x$rank
qr.x$R
solve(qr.x$R)
head(qr.x$Q)
dim(qr.x$Q)
zapsmall(t(qr.x$Q) %*% qr.x$Q)
solve(qr.x$R) %*% t(qr.x$Q) %*% y


## -------------------------------------------------------------------------------------------------------------------------------
svd.x <- SVD(X)
(Lambda <- diag(svd.x$d))
solve(Lambda)
(Cs <- svd.x$V)
zapsmall(t(Cs) %*% Cs)
Bs <- svd.x$U
dim(Bs)
head(Bs)
zapsmall(t(Bs) %*% Bs)
Cs %*% solve(Lambda) %*% t(Bs) %*% y


## -------------------------------------------------------------------------------------------------------------------------------
e <- y - X%*% b
round(t(X) %*% e, 10) # check = 0
(s2 <- as.vector((t(e) %*% e)/(100 - 3)))
(V.b <- s2*solve(t(X) %*% X))


## -------------------------------------------------------------------------------------------------------------------------------
(SE.b <- sqrt(diag(V.b)))


## -------------------------------------------------------------------------------------------------------------------------------
(t <- qt(.975, 97))


## -------------------------------------------------------------------------------------------------------------------------------
CI <- cbind(b - t*SE.b, b + t*SE.b)
rownames(CI) <- c("a", "b1", "b2")
colnames(CI) <- c(".025", ".975")
CI


## -------------------------------------------------------------------------------------------------------------------------------
confint(model)


## -------------------------------------------------------------------------------------------------------------------------------
set.seed(12345)
x <- runif(100, 0, 5)
y <- 1.5 + 0.5*x + rnorm(100, sd=1)

eqscplot(x, y)
(means <- c(mean(x), (mean(y))))
V <- var(cbind(x, y))
(sds <- sqrt(diag(V)))
ellipse(means, V, 1, col="black")
(mod.simple <- lm(y ~ x))
abline(mod.simple, lwd=2)
abline(v=means[1] + c(-sds[1], 0, sds[1]), 
       h=means[2] + c(-sds[2], 0, sds[2]), lty=2)


## -------------------------------------------------------------------------------------------------------------------------------
head(Data)
dim(Data)


## -------------------------------------------------------------------------------------------------------------------------------
with(Data, {
  eqscplot(X1, X2)
  (means <- c(mean(X1), (mean(X2))))
  V <- var(cbind(X1, X2))
  (sds <- sqrt(diag(V)))
  ellipse(means, V, 1, col="black")
  abline(v=means[1] + c(-sds[1], 0, sds[1]), 
         h=means[2] + c(-sds[2], 0, sds[2]), lty=2)
})


## -------------------------------------------------------------------------------------------------------------------------------
(b <- coef(model)[2:3]) # slopes
(V <- vcov(model)[2:3, 2:3]) # covariance matrix of the slopes

# 95% confidence ellipse:
ellipse(center=b, shape=V, radius=sqrt(2*qf(0.95, 2, 97)), col="black", 
        xlab=expression(beta[1]), ylab=expression(beta[2]),
        lty=1, fill=TRUE, add=FALSE, 
        asp=1, xlim=c(0, 2.5), ylim=c(0, 2.5))

# 95% confidence-interval generating ellipse
ellipse(center=b, shape=V, radius=sqrt(qf(0.95, 1, 97)), col="black", 
        lty=2, fill=TRUE)

(confints <- confint(model)[-1, ]) # individual confidence intervals
segments(x0=confints[1, 1], x1=confints[1, 2], y0=0, y1=0, lwd=3) # beta_1
segments(y0=confints[2, 1], y1=confints[2, 2], x0=0, x1=0, lwd=3) # beta_2

